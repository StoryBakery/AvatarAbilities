--!native
--[[
	Each frame it polls sensors, evaluates which abilities should be active,
	runs OnStep callbacks, and fires signals.
	It also manages a sleep system that skips processing when nothing is changing to save CPU.

	The engine processes abilities in this order:
	2. Evaluate sleep (skip remaining work if idle for SETTLING_FRAMES_REQUIRED+ frames)
	3. Check continuation requirements for active abilities
	4. Run OnStep for active abilities that need updating  
	5. Test activation requirements for inactive automatic abilities
	6. Fire public signals for net state changes (flicker prevention)
	--------------------------
	This engine does not execute the raw AbilityDefinition tables directly.
	Instead, it relies on "Compiled Logic" generated by the AbilityCompiler.
	- Logic Rules are flattened into Bitmasks and Disjunctive Normal Form (lists of OR variants).
	- This allows the engine to validate requirements in the hot loop using simple integer math and flat 
	  loops, avoiding expensive table recursion.

	Immediate vs. Deferred Execution
	--------------------------------
	- Resolution is Immediate: When ActivateAbility is called (or an automatic ability like "Climbing" 
	  triggers), the conflict resolution system runs instantly. It calculates winners and updates the 
	  internal state immediately.
	- Execution is Deferred: While the state changes instantly, the OnStep code for the new ability 
	  will run during the next Step cycle.
	- Signals are Transactional: Public signals are deferred until the end of the frame.
	  This prevents "signal noise" if an ability flickers on and off within the same frame.

	Sleep System
	------------
	To minimize CPU usage, the engine tracks "Dirty" states. If no sensors change and no abilities change 
	state for several frames, the engine goes to sleep, skipping the logic loop entirely until woken by an 
	event (like a key press).
]]

local AbilityEngine = {}
AbilityEngine.__index = AbilityEngine

local AbilityUtils = require("./AbilityUtils")
local checkCompiled = AbilityUtils.checkCompiled

-- The number of frames the system must be completely idle before entering sleep mode.
-- This buffer prevents rapid toggling between sleep/wake states if a sensor is jittery.
local SETTLING_FRAMES_REQUIRED = 3

-- Safety limit for the automatic activation loop.
-- Prevents infinite recursion if abilities circularly trigger each other.
local MAX_MICRO_STEPS = 100

-- Safety limit for re-validating the active list against the current labels.
-- Used when label changes force multiple cascades of deactivations.
local MAX_VALIDATION_PASSES = 10

function AbilityEngine.new(stateStore, sensorManager, baseContext, signals)
	local self = setmetatable({}, AbilityEngine)

	self.Store = stateStore
	self._sensors = sensorManager
	self.BaseContext = baseContext
	self.Signals = signals

	-- Pre-allocated buffer for conflict resolution losers (avoids GC churn)
	self._conflictBuffer = {}

	-- Sensors that need polling this frame (rebuilt when topology changes)
	self._mustPollSensors = {}

	-- Parallel arrays: closures run OnStep, records hold the ability data
	self.StepFunctions = {}
	self.StepRecords = {}

	-- Sleep system: idle frames counter and flag
	self._settlingFrames = 0
	self._isSleeping = false

	-- -1 forces a full rebuild on frame 1 (store starts at version 0)
	self._lastCacheVersion = -1

	-- Re-entrancy guard (protects shared buffers like _conflictBuffer)
	self._inStep = false

	-- Wake from sleep on state/config/sensor changes
	self._activeConnection = stateStore.AbilityActiveChanged:Connect(function(name, active)
		local record = stateStore.RecordsByName[name]
		if not active then
			-- If deactivated, we must remove it immediately to prevent it from running
			-- in the current frame if we are mid-step.
			self:_removeStepper(record)
		end
		-- We do NOT add steppers here. We wait for the next Step() to rebuild
		-- the list based on the new cache version.

		if self._isSleeping then
			self._isSleeping = false
			self._settlingFrames = 0
		end
	end)

	self._enabledConnection = stateStore.AbilityEnabledChanged:Connect(function()
		if self._isSleeping then
			self._isSleeping = false
			self._settlingFrames = 0
		end
	end)

	-- Config change wakes so the stepper re-reads values via record._needsStep
	self._configConnection = stateStore.AbilityConfigChanged:Connect(function()
		if self._isSleeping then
			self._isSleeping = false
			self._settlingFrames = 0
		end
	end)

	self._triggeredConnection = sensorManager.Triggered:Connect(function()
		if self._isSleeping then
			self._isSleeping = false
			self._settlingFrames = 0
		end
	end)

	return self
end

-- Rebuilds the list of sensors that need polling based on active and candidate abilities.
function AbilityEngine:_rebuildPollingSensors(frameCtx)
	local cache = self.Store.Cache
	local required = {}

	-- StepSensors are always force-polled
	local forcePolled = {}

	local list = self._mustPollSensors
	table.clear(list)

	-- Extract sensor names from a compiled logic block
	local function collect(compiled)
		if not compiled then
			return
		end
		for i = 1, compiled.variantCount do
			local v = compiled.variants[i]
			for s = 1, v.sensorCount do
				required[v.sensorNames[s]] = true
			end
			for s = 1, v.invertedCount do
				required[v.invertedNames[s]] = true
			end
		end
	end

	-- Collect sensors needed by active abilities' continuation rules
	for _, record in cache.ActiveAbilities do
		collect(record._compiledContinuation)
		if record._stepSensors then
			for _, name in record._stepSensors do
				required[name] = true
				forcePolled[name] = true
				if AbilityUtils.DEBUG_SENSORS then
					print("[Engine] StepSensor found:", name, "for ability:", record.Name)
				end
			end
		end
	end

	-- Collect sensors needed by automatic candidates' activation rules
	for _, record in cache.ContinuousCandidates do
		collect(record._compiledActivation)
	end

	-- Only add Polled or StepSensor-forced sensors to the poll list
	local sensorDefs = self._sensors:GetSensors()
	for name in required do
		local def = sensorDefs[name]
		if def and def.getter then
			if def.poll or forcePolled[name] then
				table.insert(list, name)
				if frameCtx then
					self._sensors:GetSensor(name, frameCtx)
				end
			end
		elseif AbilityUtils.DEBUG_SENSORS and forcePolled[name] then
			print("[Engine] StepSensor", name, "not found in sensorDefs! def=", def)
		end
	end
end

-- Rebuilds the StepFunctions and StepRecords arrays from the Store's sorted ActiveAbilities.
-- This is called once per frame ONLY if the cache version (topology) has changed.
function AbilityEngine:_rebuildSteppers()
	-- Clear the dense arrays
	table.clear(self.StepFunctions)
	table.clear(self.StepRecords)

	local activeAbilities = self.Store.Cache.ActiveAbilities

	for i = 1, #activeAbilities do
		local record = activeAbilities[i]

		-- If the closure doesn't exist (newly activated), create and cache it on the record.
		-- It stays cached until the ability is deactivated (see _removeStepper).
		if not record._stepClosure then
			record._stepClosure = self:_createStepper(record)
		end

		self.StepFunctions[i] = record._stepClosure
		self.StepRecords[i] = record

		-- Track the index so _removeStepper can zero-out the slot efficiently
		record._stepIndex = i
	end
end

-- Main per-frame update: polls sensors, runs steppers, evaluates candidates.
function AbilityEngine:Step(frameCtx)
	if self._inStep then
		return
	end

	self._sensors:BeginFrame()
	self._inStep = true

	local debugLazyList = AbilityUtils.DEBUG_SENSORS and {} or nil
	local topologyChanged = false

	-- Rebuild on topology change.
	if self._lastCacheVersion ~= self.Store.Cache.Version then
		-- Update sensors based on current (potentially dirty) state
		self:_rebuildPollingSensors(frameCtx)

		-- Validate (this may deactivate abilities and bump Cache.Version)
		self:_validateActiveAbilities()

		-- Snapshot version after all deactivations have settled
		self._lastCacheVersion = self.Store.Cache.Version

		-- Sync our dense execution arrays to the final settled list
		self:_rebuildSteppers()

		topologyChanged = true
	end

	-- Poll required sensors
	local sensors = self._sensors
	local GetSensor = sensors.GetSensor

	-- Cache sensor references outside the loop to avoid repeated lookups
	for _, s in ipairs(self._mustPollSensors) do
		GetSensor(sensors, s, frameCtx)
	end

	-- Dirty = topology changed or sensor value changed
	local sensorsDirty = self._sensors:IsDirty() or self._sensors:HasDiscreteActivity()
	local dirty = sensorsDirty or topologyChanged

	-- Sleep logic
	if not dirty and self.Store.Cache.NonSleepableCount == 0 then
		self._settlingFrames += 1

		if self._settlingFrames >= SETTLING_FRAMES_REQUIRED then
			if not self._isSleeping then
				self._isSleeping = true
				self.Signals.SleepStateChanged:Fire(true)
			end
			self._sensors:EndFrame()
			self.Store:EndFrame(self.Signals)
			self._inStep = false
			return
		end
	else
		-- Activity detected, reset idle counter
		self._settlingFrames = 0
		if self._isSleeping then
			self._isSleeping = false
			self.Signals.SleepStateChanged:Fire(false)
		end
	end

	-- Run OnStep closures for active abilities
	local forceRun = self.Store.Cache.NonSleepableCount > 0

	-- Run OnStep closures for active abilities (priority order).
	-- NOTE: Use a numeric for-loop instead of ipairs. Mid-loop deactivations (via _removeStepper)
	-- will 'punch a hole' by setting a slot to nil. ipairs would stop at that nil and skip
	-- subsequent abilities, whereas this numeric loop safely skips the hole and continues.
	for i = 1, #self.StepFunctions do
		local func = self.StepFunctions[i]
		if func then
			func(frameCtx, dirty, forceRun, debugLazyList)
		end
	end

	-- Evaluate automatic candidates (bounded to prevent infinite cascades)
	local candidates = self.Store.Cache.ContinuousCandidates
	local visited = {}
	local candidateIndex = 1

	for _ = 1, MAX_MICRO_STEPS do
		if candidateIndex > #candidates then
			break
		end

		local record = candidates[candidateIndex]

		if record and not record.IsActive and not visited[record] then
			-- Labels + sensors must both pass before attempting resolution
			if
				checkCompiled(
					record._compiledActivation,
					self.Store.Cache.ActiveMaskLo,
					self.Store.Cache.ActiveMaskHi,
					self._sensors,
					frameCtx,
					debugLazyList
				)
			then
				visited[record] = true
				local preVersion = self.Store.Cache.Version

				self:_attemptResolutionAndStart(record)

				-- Version changed = topology shifted, restart scan
				if self.Store.Cache.Version ~= preVersion then
					candidates = self.Store.Cache.ContinuousCandidates
					candidateIndex = 1 -- Reset index to 1 to restart
					continue
				end
			end
		end

		-- Move to the next candidate
		candidateIndex += 1
	end

	if AbilityUtils.DEBUG_SENSORS then
		local polling = self._mustPollSensors
		local pollStr = table.concat(polling, ", ")
		local lazyKeys = {}
		for k in debugLazyList do
			table.insert(lazyKeys, k)
		end
		local lazyStr = table.concat(lazyKeys, ", ")
		if pollStr ~= "" or lazyStr ~= "" then
			print(string.format("[Engine] [Poll]: %s || [Lazy]: %s", pollStr, lazyStr))
		end
	end

	-- Finalize: clear per-frame caches and fire deferred signals
	self._sensors:EndFrame()
	self.Store:EndFrame(self.Signals)
	self._inStep = false
end

-- Generates a specialized closure for an ability's per-frame logic.
-- Avoids per-frame branching on OnStep/RequiresToContinue presence.
function AbilityEngine:_createStepper(record)
	local name = record.Name
	local function getContinuation()
		return record._compiledContinuation
	end
	local onStep = record._onStepFunc
	local engine = self
	local sensors = self._sensors

	-- Augmented State: plain (baseCtx, frameCtx, state), no bridging overhead
	local baseCtx = self.BaseContext
	local state = record._state

	-- Fallback for abilities without DataModel binding (legacy / testing)
	if not state then
		state = record.State
	end

	-- Determine if this ability needs to run every frame or only when sensors change.
	local alwaysRun = (record._stepSensors == nil) or (record._canSleep == false)
	local needsInit = true

	-- No OnStep: only generate continuation checking
	if not onStep then
		return function(frameCtx, _dirty, _forceRun, debugLazyList)
			local continuation = getContinuation()
			if
				continuation
				and not checkCompiled(
					continuation,
					engine.Store.Cache.ActiveMaskLo,
					engine.Store.Cache.ActiveMaskHi,
					sensors,
					frameCtx,
					debugLazyList
				)
			then
				engine:_setAbilityActive(name, false)
			end
		end
	end

	-- Has OnStep: always check continuation dynamically (it may be added later by RefreshLogic).
	return function(frameCtx, dirty, forceRun, debugLazyList)
		local continuation = getContinuation()
		if
			continuation
			and not checkCompiled(
				continuation,
				engine.Store.Cache.ActiveMaskLo,
				engine.Store.Cache.ActiveMaskHi,
				sensors,
				frameCtx,
				debugLazyList
			)
		then
			engine:_setAbilityActive(name, false)
			return
		end
		if alwaysRun or dirty or forceRun or needsInit or record._needsStep then
			record._needsStep = nil
			onStep(baseCtx, frameCtx, state)
			needsInit = false
		end
	end
end

-- Remove a stepper from the active list.
-- This effectively "punches a hole" in the current frame's execution list
-- and clears the cached closure so it's rebuilt fresh if reactivated.
function AbilityEngine:_removeStepper(record)
	-- Nil the slot in the current frame's arrays so the loop skips it
	local index = record._stepIndex
	if index then
		self.StepFunctions[index] = nil
		self.StepRecords[index] = nil
		record._stepIndex = nil
	end

	-- Clear the closure so we don't hold onto stale state if it reactivates later
	record._stepClosure = nil
end

function AbilityEngine:_setAbilityActive(name, active)
	self.Store:SetAbilityActive(name, active)
end

-- Re-validates active abilities against the current label mask.
-- Cascading deactivations are bounded by MAX_VALIDATION_PASSES.
function AbilityEngine:_validateActiveAbilities()
	for _ = 1, MAX_VALIDATION_PASSES do
		local changes = false
		local active = self.Store.Cache.ActiveAbilities

		local snapshot = table.clone(active)

		for i = 1, #snapshot do
			local record = snapshot[i]
			if record.IsActive and record._compiledContinuation then
				-- Labels only (sensors checked in stepper)
				if
					not AbilityUtils.checkLabels(
						record._compiledContinuation,
						self.Store.Cache.ActiveMaskLo,
						self.Store.Cache.ActiveMaskHi
					)
				then
					self:_setAbilityActive(record.Name, false)
					changes = true
				end
			end
		end

		if not changes then
			break
		end
	end
end

-- Resolves conflicts and starts an ability if resolution succeeds.
function AbilityEngine:_attemptResolutionAndStart(record)
	if record.IsActive or not record.IsEnabled then
		return
	end

	table.clear(self._conflictBuffer)
	local success = AbilityUtils.resolveConflicts(
		record,
		self.Store.Cache.ActiveAbilities,
		self.Store.Cache.GroupWinners,
		self._conflictBuffer
	)

	if success and not record.IsActive then
		for _, conflict in self._conflictBuffer do
			self:_setAbilityActive(conflict.Name, false)
		end
		self:_setAbilityActive(record.Name, true)
	end
end

-- Clean up
function AbilityEngine:Destroy()
	if self._activeConnection then
		self._activeConnection:Disconnect()
	end
	if self._enabledConnection then
		self._enabledConnection:Disconnect()
	end
	if self._configConnection then
		self._configConnection:Disconnect()
	end
	if self._triggeredConnection then
		self._triggeredConnection:Disconnect()
	end
	table.clear(self._conflictBuffer)
	table.clear(self._mustPollSensors)
	table.clear(self.StepFunctions)
	table.clear(self.StepRecords)
	self.Store = nil
	self._sensors = nil
	self.BaseContext = nil
	self.Signals = nil
end

return AbilityEngine
